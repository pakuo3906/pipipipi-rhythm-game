<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipipipi Rhythm Game - Embed Version</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            min-height: 400px;
        }

        #gameCanvas {
            background: rgba(0, 0, 0, 0.1);
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .combo-display {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }

        .control-btn {
            padding: 5px 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .start-screen h1 {
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        }

        .start-screen p {
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
            max-width: 90%;
            line-height: 1.4;
        }

        .start-btn {
            padding: 10px 30px;
            font-size: 16px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .judgment-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .judgment-perfect { color: #ffeb3b; }
        .judgment-good { color: #4caf50; }
        .judgment-miss { color: #f44336; }

        /* Âüã„ÇÅËæº„ÅøÁî®„ÅÆ„Ç≥„É≥„Éë„ÇØ„Éà„É¨„Ç§„Ç¢„Ç¶„Éà */
        @media (max-width: 600px) {
            .start-screen h1 {
                font-size: 20px;
            }
            
            .start-screen p {
                font-size: 12px;
            }
            
            .score-display, .combo-display {
                font-size: 14px;
            }
            
            .judgment-display {
                font-size: 18px;
            }
        }

        /* Âüã„ÇÅËæº„Åø iframe Áî®„ÅÆË™øÊï¥ */
        @media (max-height: 400px) {
            .start-screen h1 {
                font-size: 18px;
                margin-bottom: 10px;
            }
            
            .start-screen p {
                font-size: 11px;
                margin-bottom: 15px;
            }
            
            .start-btn {
                padding: 8px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div class="score-display">
                Score: <span id="scoreValue">0</span>
            </div>
            <div class="combo-display">
                Combo: <span id="comboValue">0</span>
            </div>
            <div class="judgment-display" id="judgmentDisplay"></div>
        </div>

        <div class="controls">
            <button class="control-btn" id="pauseBtn">Pause</button>
            <button class="control-btn" id="retryBtn">Retry</button>
            <div class="volume-control" style="display: flex; align-items: center; gap: 5px; margin-left: 10px;">
                <span style="font-size: 12px;">üîä</span>
                <input type="range" id="volumeSlider" min="0" max="100" value="70" 
                       style="width: 60px; height: 3px; background: rgba(255,255,255,0.3); border-radius: 2px;">
            </div>
        </div>

        <div class="start-screen" id="startScreen">
            <h1>üéµ Pipipipi Rhythm üéµ</h1>
            <p>
                AÔºàÂ∑¶Ôºâ„ÉªSÔºà‰∏≠Â§ÆÔºâ„ÉªDÔºàÂè≥Ôºâ„Ç≠„Éº„Åæ„Åü„ÅØ„Çø„ÉÉ„Éó„ÅßÊºîÂ•èÔºÅ<br>
                „É™„ÉÉ„ÉÅ„Å™„Ç®„Éï„Çß„ÇØ„Éà„Åß„É™„Ç∫„É†„ÇíÊ•Ω„Åó„ÇÇ„ÅÜÔºÅ
            </p>
            <button class="start-btn" id="startBtn">START</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script>
        // Âüã„ÇÅËæº„ÅøÁî®„ÅÆ„Ç≥„É≥„Éë„ÇØ„Éà„Éê„Éº„Ç∏„Éß„É≥
        class CompactRhythmGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.audioContext = null;
                this.audioBuffer = null;
                this.audioSource = null;
                this.analyser = null;
                this.frequencyData = null;
                
                this.gameState = 'start';
                this.score = 0;
                this.combo = 0;
                this.startTime = 0;
                this.currentTime = 0;
                
                this.chartData = null;
                this.noteIndex = 0;
                this.notes = [];
                this.particles = [];
                
                this.settings = {
                    noteSpeed: 250,
                    judgeLineY: 0,
                    laneWidth: 0,
                    lanePositions: [],
                    judgeWindow: { perfect: 0.1, good: 0.2, miss: 0.3 }
                };
                
                this.keys = { 'KeyA': 0, 'KeyS': 1, 'KeyD': 2 };
                this.effects = { ripples: [], backgroundPulse: 0, laneGlow: [0, 0, 0] };
                
                this.init();
            }

            async init() {
                this.setupCanvas();
                this.setupEventListeners();
                await this.loadChart();
                this.setupAudio();
                this.resizeCanvas();
                this.render();
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.settings.judgeLineY = this.canvas.height * 0.8;
                this.settings.laneWidth = this.canvas.width / 3;
                this.settings.lanePositions = [
                    this.settings.laneWidth * 0.5,
                    this.settings.laneWidth * 1.5,
                    this.settings.laneWidth * 2.5
                ];
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameState !== 'playing') return;
                    const lane = this.keys[e.code];
                    if (lane !== undefined) this.handleInput(lane);
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.togglePause();
                    }
                });

                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState !== 'playing') return;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const lane = Math.floor(x / this.settings.laneWidth);
                    if (lane >= 0 && lane < 3) this.handleInput(lane);
                });

                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('retryBtn').addEventListener('click', () => this.retryGame());
                
                // Èü≥ÈáèË™øÊï¥
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    this.setVolume(e.target.value / 100);
                });
            }

            async loadChart() {
                const chartData = {
                    "songInfo": {"title": "„Å¥„Å¥„Å¥‚Ä¶ „Åó„Çì„Åî„ÅÜ‚Ä¶", "artist": "pa9wo", "duration": 217.87, "bpm": 150},
                    "chart": [
                        {"time": 0.5, "type": "tap", "lane": "S"}, {"time": 1.2, "type": "tap", "lane": "A"}, {"time": 2.0, "type": "tap", "lane": "D"},
                        {"time": 3.1, "type": "tap", "lane": "S"}, {"time": 4.5, "type": "tap", "lane": "A"}, {"time": 5.2, "type": "tap", "lane": "D"},
                        {"time": 6.0, "type": "tap", "lane": "S"}, {"time": 7.3, "type": "tap", "lane": "D"}, {"time": 8.8, "type": "tap", "lane": "A"},
                        {"time": 9.5, "type": "tap", "lane": "S"}, {"time": 10.2, "type": "tap", "lane": "D"}, {"time": 11.0, "type": "tap", "lane": "A"},
                        {"time": 12.5, "type": "tap", "lane": "S"}, {"time": 13.2, "type": "tap", "lane": "D"}, {"time": 14.0, "type": "tap", "lane": "A"}
                    ]
                };
                this.chartData = chartData;
            }

            async setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 128;
                    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    // Èü≥ÈáèË®≠ÂÆö
                    this.audioSettings = {
                        masterVolume: 0.7,
                        volumeNode: null
                    };
                    
                    this.audioSettings.volumeNode = this.audioContext.createGain();
                    this.audioSettings.volumeNode.gain.value = this.audioSettings.masterVolume;
                } catch (error) {
                    console.error('Audio setup failed:', error);
                }
            }

            async startGame() {
                document.getElementById('startScreen').style.display = 'none';
                this.gameState = 'playing';
                this.score = 0;
                this.combo = 0;
                this.noteIndex = 0;
                this.notes = [];
                this.particles = [];
                this.startTime = Date.now();
                this.pausedTime = 0;
                this.animationId = null;
                this.updateUI();
                this.gameLoop();
            }

            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.pausedTime = Date.now();
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    // „Éù„Éº„Ç∫ÊôÇÈñì„ÇíËÄÉÊÖÆ„Åó„Å¶startTime„ÇíË™øÊï¥
                    const pauseDuration = Date.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.gameLoop();
                }
            }

            retryGame() {
                this.gameState = 'start';
                document.getElementById('startScreen').style.display = 'flex';
            }

            setVolume(volume) {
                this.audioSettings.masterVolume = volume;
                if (this.audioSettings.volumeNode) {
                    this.audioSettings.volumeNode.gain.value = volume;
                }
            }

            handleInput(lane) {
                const currentTime = (Date.now() - this.startTime) / 1000;
                let bestNote = null;
                let bestDistance = Infinity;

                for (let i = 0; i < this.notes.length; i++) {
                    const note = this.notes[i];
                    if (note.lane === lane && !note.hit) {
                        const distance = Math.abs(note.time - currentTime);
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestNote = note;
                        }
                    }
                }

                if (bestNote) this.judgeNote(bestNote, bestDistance);
            }

            judgeNote(note, distance) {
                let judgment = 'miss';
                let points = 0;
                
                if (distance <= this.settings.judgeWindow.perfect) {
                    judgment = 'perfect';
                    points = 300;
                    this.combo++;
                } else if (distance <= this.settings.judgeWindow.good) {
                    judgment = 'good';
                    points = 100;
                    this.combo++;
                } else {
                    judgment = 'miss';
                    points = 0;
                    this.combo = 0;
                }

                note.hit = true;
                this.score += points * (1 + this.combo * 0.1);
                
                this.addRipple(note.lane, judgment);
                this.addParticles(note.lane, judgment);
                this.effects.laneGlow[note.lane] = 1.0;
                
                this.showJudgment(judgment);
                this.updateUI();
            }

            addRipple(lane, judgment) {
                const colors = { perfect: '#ffeb3b', good: '#4caf50', miss: '#f44336' };
                this.effects.ripples.push({
                    x: this.settings.lanePositions[lane],
                    y: this.settings.judgeLineY,
                    radius: 0,
                    maxRadius: 60,
                    color: colors[judgment],
                    life: 1.0
                });
            }

            addParticles(lane, judgment) {
                const colors = {
                    perfect: ['#ffeb3b', '#fff59d', '#ffcc02'],
                    good: ['#4caf50', '#81c784', '#388e3c'],
                    miss: ['#f44336', '#e57373', '#d32f2f']
                };
                
                const particleCount = judgment === 'perfect' ? 15 : judgment === 'good' ? 8 : 3;
                const x = this.settings.lanePositions[lane];
                const y = this.settings.judgeLineY;
                
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 15,
                        y: y + (Math.random() - 0.5) * 15,
                        vx: (Math.random() - 0.5) * 150,
                        vy: (Math.random() - 0.5) * 150 - 80,
                        color: colors[judgment][Math.floor(Math.random() * colors[judgment].length)],
                        life: 1.0,
                        size: Math.random() * 4 + 2
                    });
                }
                
                if (judgment === 'perfect') {
                    confetti({
                        particleCount: 20,
                        spread: 50,
                        origin: { 
                            x: x / this.canvas.width, 
                            y: y / this.canvas.height 
                        },
                        colors: ['#ffeb3b', '#fff59d', '#ffcc02']
                    });
                }
            }

            showJudgment(judgment) {
                const display = document.getElementById('judgmentDisplay');
                display.textContent = judgment.toUpperCase();
                display.className = `judgment-display judgment-${judgment}`;
                display.style.opacity = '1';
                setTimeout(() => display.style.opacity = '0', 400);
            }

            updateUI() {
                document.getElementById('scoreValue').textContent = Math.floor(this.score);
                document.getElementById('comboValue').textContent = this.combo;
            }

            gameLoop() {
                if (this.gameState !== 'playing') return;
                
                this.currentTime = (Date.now() - this.startTime) / 1000;
                this.updateNotes();
                this.updateEffects();
                this.render();
                
                this.animationId = requestAnimationFrame(() => this.gameLoop());
            }

            updateNotes() {
                // Êñ∞„Åó„ÅÑ„Éé„Éº„Éà„ÇíËøΩÂä†ÔºàÁîªÈù¢‰∏äÈÉ®„Åã„Çâ„Çπ„Çø„Éº„ÉàÔºâ
                while (this.noteIndex < this.chartData.chart.length) {
                    const chartNote = this.chartData.chart[this.noteIndex];
                    // „Éé„Éº„Éà„ÅåÁîªÈù¢‰∏äÈÉ®„Åã„ÇâÂá∫Áèæ„Åô„Çã„Çà„ÅÜ„Å´Ë™øÊï¥ÔºàËêΩ‰∏ãË∑ùÈõ¢„ÇíÈï∑„Åè„Åô„ÇãÔºâ
                    const fallDistance = this.canvas.height + 100; // ÁîªÈù¢‰∏äÈÉ®„Åã„ÇâÂà§ÂÆö„É©„Ç§„É≥„Åæ„Åß + ‰ΩôË£ï
                    const spawnTime = chartNote.time - fallDistance / this.settings.noteSpeed;
                    
                    if (this.currentTime >= spawnTime) {
                        this.notes.push({
                            time: chartNote.time,
                            lane: chartNote.lane === 'S' ? 1 : chartNote.lane === 'A' ? 0 : 2, // A=0(Â∑¶), S=1(‰∏≠Â§Æ), D=2(Âè≥)
                            y: -100, // ÁîªÈù¢‰∏äÈÉ®„Åã„ÇâÈñãÂßã
                            hit: false
                        });
                        this.noteIndex++;
                    } else {
                        break;
                    }
                }

                // „Éé„Éº„Éà„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                for (let i = this.notes.length - 1; i >= 0; i--) {
                    const note = this.notes[i];
                    const timeDistance = note.time - this.currentTime;
                    note.y = this.settings.judgeLineY - (timeDistance * this.settings.noteSpeed);
                    
                    // ÁîªÈù¢Â§ñ„ÅÆ„Éé„Éº„Éà„ÇíÂâäÈô§
                    if (note.y > this.canvas.height + 50) {
                        if (!note.hit) this.combo = 0;
                        this.notes.splice(i, 1);
                    }
                    
                    // Âà§ÂÆö„É©„Ç§„É≥„ÇíÈÅé„Åé„Åü„Éé„Éº„Éà„ÅÆËá™ÂãïMissÂà§ÂÆö
                    if (note.y > this.settings.judgeLineY + 50 && !note.hit) {
                        note.hit = true;
                        this.combo = 0;
                        this.showJudgment('miss');
                        this.updateUI();
                    }
                }
            }

            updateEffects() {
                for (let i = this.effects.ripples.length - 1; i >= 0; i--) {
                    const ripple = this.effects.ripples[i];
                    ripple.radius += 150 * (1/60);
                    ripple.life -= 1/60;
                    if (ripple.life <= 0) this.effects.ripples.splice(i, 1);
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx * (1/60);
                    particle.y += particle.vy * (1/60);
                    particle.vy += 400 * (1/60);
                    particle.life -= 1/60;
                    if (particle.life <= 0) this.particles.splice(i, 1);
                }

                for (let i = 0; i < 3; i++) {
                    this.effects.laneGlow[i] *= 0.85;
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ËÉåÊôØ
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.1)');
                gradient.addColorStop(1, 'rgba(118, 75, 162, 0.1)');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // „É¨„Éº„É≥
                for (let i = 0; i < 3; i++) {
                    const x = i * this.settings.laneWidth;
                    const glow = this.effects.laneGlow[i];
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.08 + glow * 0.2})`;
                    this.ctx.fillRect(x, 0, this.settings.laneWidth, this.canvas.height);
                    
                    if (i < 2) {
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + glow * 0.3})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x + this.settings.laneWidth, 0);
                        this.ctx.lineTo(x + this.settings.laneWidth, this.canvas.height);
                        this.ctx.stroke();
                    }
                }
                
                // Âà§ÂÆö„É©„Ç§„É≥
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.fillRect(0, this.settings.judgeLineY - 1, this.canvas.width, 2);
                
                // „Éé„Éº„Éà
                for (const note of this.notes) {
                    if (note.hit) continue;
                    
                    const x = this.settings.lanePositions[note.lane];
                    const y = note.y;
                    const radius = 15;
                    
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#4fc3f7');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#01579b';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // „Ç®„Éï„Çß„ÇØ„Éà
                for (const ripple of this.effects.ripples) {
                    this.ctx.globalAlpha = ripple.life * 0.6;
                    this.ctx.strokeStyle = ripple.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                for (const particle of this.particles) {
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.globalAlpha = 1;
            }
        }

        // Âüã„ÇÅËæº„ÅøÁî®„Ç≥„É≥„Éë„ÇØ„Éà„Ç≤„Éº„É†ÂàùÊúüÂåñ
        const game = new CompactRhythmGame();
    </script>
</body>
</html>